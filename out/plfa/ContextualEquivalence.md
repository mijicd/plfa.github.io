---
src       : "src/plfa/ContextualEquivalence.lagda.md"
title     : "ContextualEquivalence: Denotational equality implies contextual equivalence"
layout    : page
prev      : /Adequacy/
permalink : /ContextualEquivalence/
next      : /Substitution/
---

{% raw %}<pre class="Agda"><a id="207" class="Keyword">module</a> <a id="214" href="{% endraw %}{{ site.baseurl }}{% link out/plfa/ContextualEquivalence.md %}{% raw %}" class="Module">plfa.ContextualEquivalence</a> <a id="241" class="Keyword">where</a>
</pre>{% endraw %}
## Imports

{% raw %}<pre class="Agda"><a id="268" class="Keyword">open</a> <a id="273" class="Keyword">import</a> <a id="280" href="{% endraw %}{{ site.baseurl }}{% link out/plfa/Untyped.md %}{% raw %}" class="Module">plfa.Untyped</a> <a id="293" class="Keyword">using</a> <a id="299" class="Symbol">(</a><a id="300" href="plfa.Untyped.html#4252" class="Datatype Operator">_⊢_</a><a id="303" class="Symbol">;</a> <a id="305" href="plfa.Untyped.html#2876" class="InductiveConstructor">★</a><a id="306" class="Symbol">;</a> <a id="308" href="plfa.Untyped.html#3152" class="InductiveConstructor">∅</a><a id="309" class="Symbol">;</a> <a id="311" href="plfa.Untyped.html#3168" class="InductiveConstructor Operator">_,_</a><a id="314" class="Symbol">;</a> <a id="316" href="plfa.Untyped.html#4340" class="InductiveConstructor Operator">ƛ_</a><a id="318" class="Symbol">;</a> <a id="320" href="plfa.Untyped.html#11203" class="Datatype Operator">_—↠_</a><a id="324" class="Symbol">)</a>
<a id="326" class="Keyword">open</a> <a id="331" class="Keyword">import</a> <a id="338" href="{% endraw %}{{ site.baseurl }}{% link out/plfa/Denotational.md %}{% raw %}" class="Module">plfa.Denotational</a> <a id="356" class="Keyword">using</a> <a id="362" class="Symbol">(</a><a id="363" href="plfa.Denotational.html#17453" class="Function">ℰ</a><a id="364" class="Symbol">;</a> <a id="366" href="plfa.Denotational.html#17635" class="Function Operator">_≃_</a><a id="369" class="Symbol">;</a> <a id="371" href="plfa.Denotational.html#17907" class="Function">≃-sym</a><a id="376" class="Symbol">;</a> <a id="378" href="plfa.Denotational.html#18040" class="Function">≃-trans</a><a id="385" class="Symbol">;</a> <a id="387" href="plfa.Denotational.html#16974" class="Function Operator">_iff_</a><a id="392" class="Symbol">)</a>
<a id="394" class="Keyword">open</a> <a id="399" class="Keyword">import</a> <a id="406" href="{% endraw %}{{ site.baseurl }}{% link out/plfa/Compositional.md %}{% raw %}" class="Module">plfa.Compositional</a> <a id="425" class="Keyword">using</a> <a id="431" class="Symbol">(</a><a id="432" href="plfa.Compositional.html#13621" class="Datatype">Ctx</a><a id="435" class="Symbol">;</a> <a id="437" href="plfa.Compositional.html#14673" class="Function">plug</a><a id="441" class="Symbol">;</a> <a id="443" href="plfa.Compositional.html#15068" class="Function">compositionality</a><a id="459" class="Symbol">)</a>
<a id="461" class="Keyword">open</a> <a id="466" class="Keyword">import</a> <a id="473" href="{% endraw %}{{ site.baseurl }}{% link out/plfa/Soundness.md %}{% raw %}" class="Module">plfa.Soundness</a> <a id="488" class="Keyword">using</a> <a id="494" class="Symbol">(</a><a id="495" href="plfa.Soundness.html#23397" class="Function">soundness</a><a id="504" class="Symbol">)</a>
<a id="506" class="Keyword">open</a> <a id="511" class="Keyword">import</a> <a id="518" href="{% endraw %}{{ site.baseurl }}{% link out/plfa/Adequacy.md %}{% raw %}" class="Module">plfa.Adequacy</a> <a id="532" class="Keyword">using</a> <a id="538" class="Symbol">(</a><a id="539" href="plfa.Adequacy.html#20838" class="Function">adequacy</a><a id="547" class="Symbol">)</a>
<a id="549" class="Keyword">open</a> <a id="554" class="Keyword">import</a> <a id="561" href="{% endraw %}{{ site.baseurl }}{% link out/plfa/CallByName.md %}{% raw %}" class="Module">plfa.CallByName</a> <a id="577" class="Keyword">using</a> <a id="583" class="Symbol">(</a><a id="584" href="plfa.CallByName.html#3038" class="Datatype Operator">_⊢_⇓_</a><a id="589" class="Symbol">;</a> <a id="591" href="plfa.CallByName.html#12248" class="Function">cbn→reduce</a><a id="601" class="Symbol">)</a>

<a id="604" class="Keyword">open</a> <a id="609" class="Keyword">import</a> <a id="616" href="https://agda.github.io/agda-stdlib/v1.1/Data.Product.html" class="Module">Data.Product</a> <a id="629" class="Keyword">using</a> <a id="635" class="Symbol">(</a><a id="636" href="https://agda.github.io/agda-stdlib/v1.1/Data.Product.html#1162" class="Function Operator">_×_</a><a id="639" class="Symbol">;</a> <a id="641" href="Agda.Builtin.Sigma.html#139" class="Record">Σ</a><a id="642" class="Symbol">;</a> <a id="644" href="https://agda.github.io/agda-stdlib/v1.1/Data.Product.html#911" class="Function">Σ-syntax</a><a id="652" class="Symbol">;</a> <a id="654" href="https://agda.github.io/agda-stdlib/v1.1/Data.Product.html#1364" class="Function">∃</a><a id="655" class="Symbol">;</a> <a id="657" href="https://agda.github.io/agda-stdlib/v1.1/Data.Product.html#1783" class="Function">∃-syntax</a><a id="665" class="Symbol">;</a> <a id="667" href="Agda.Builtin.Sigma.html#225" class="Field">proj₁</a><a id="672" class="Symbol">;</a> <a id="674" href="Agda.Builtin.Sigma.html#237" class="Field">proj₂</a><a id="679" class="Symbol">)</a>
  <a id="683" class="Keyword">renaming</a> <a id="692" class="Symbol">(</a><a id="693" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">_,_</a> <a id="697" class="Symbol">to</a> <a id="700" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">⟨_,_⟩</a><a id="705" class="Symbol">)</a>
</pre>{% endraw %}
## Contextual Equivalence

The notion of _contextual equivalence_ is an important one for
programming languages because it is the sufficient condition for
changing a subterm of a program while maintaining the program's
overall behavior. Two terms `M` and `N` are contextually equivalent
if they can plugged into any context `C` and produce equivalent
results. As discuss in the Denotational chapter, the result of
a program in the lambda calculus is to terminate or not.
We characterize termination with the reduction semantics as follows.

{% raw %}<pre class="Agda"><a id="terminates"></a><a id="1257" href="{% endraw %}{{ site.baseurl }}{% link out/plfa/ContextualEquivalence.md %}{% raw %}#1257" class="Function">terminates</a> <a id="1268" class="Symbol">:</a> <a id="1270" class="Symbol">∀{</a><a id="1272" href="plfa.ContextualEquivalence.html#1272" class="Bound">Γ</a><a id="1273" class="Symbol">}</a> <a id="1275" class="Symbol">→</a> <a id="1277" class="Symbol">(</a><a id="1278" href="plfa.ContextualEquivalence.html#1278" class="Bound">M</a> <a id="1280" class="Symbol">:</a> <a id="1282" href="plfa.ContextualEquivalence.html#1272" class="Bound">Γ</a> <a id="1284" href="{% endraw %}{{ site.baseurl }}{% link out/plfa/Untyped.md %}{% raw %}#4252" class="Datatype Operator">⊢</a> <a id="1286" href="plfa.Untyped.html#2876" class="InductiveConstructor">★</a><a id="1287" class="Symbol">)</a> <a id="1289" class="Symbol">→</a> <a id="1291" class="PrimitiveType">Set</a>
<a id="1295" href="{% endraw %}{{ site.baseurl }}{% link out/plfa/ContextualEquivalence.md %}{% raw %}#1257" class="Function">terminates</a> <a id="1306" class="Symbol">{</a><a id="1307" href="plfa.ContextualEquivalence.html#1307" class="Bound">Γ</a><a id="1308" class="Symbol">}</a> <a id="1310" href="plfa.ContextualEquivalence.html#1310" class="Bound">M</a> <a id="1312" class="Symbol">=</a> <a id="1314" href="https://agda.github.io/agda-stdlib/v1.1/Data.Product.html#911" class="Function">Σ[</a> <a id="1317" href="plfa.ContextualEquivalence.html#1317" class="Bound">N</a> <a id="1319" href="https://agda.github.io/agda-stdlib/v1.1/Data.Product.html#911" class="Function">∈</a> <a id="1321" class="Symbol">(</a><a id="1322" href="plfa.ContextualEquivalence.html#1307" class="Bound">Γ</a> <a id="1324" href="{% endraw %}{{ site.baseurl }}{% link out/plfa/Untyped.md %}{% raw %}#3168" class="InductiveConstructor Operator">,</a> <a id="1326" href="plfa.Untyped.html#2876" class="InductiveConstructor">★</a> <a id="1328" href="plfa.Untyped.html#4252" class="Datatype Operator">⊢</a> <a id="1330" href="plfa.Untyped.html#2876" class="InductiveConstructor">★</a><a id="1331" class="Symbol">)</a> <a id="1333" href="https://agda.github.io/agda-stdlib/v1.1/Data.Product.html#911" class="Function">]</a> <a id="1335" class="Symbol">(</a><a id="1336" href="plfa.ContextualEquivalence.html#1310" class="Bound">M</a> <a id="1338" href="plfa.Untyped.html#11203" class="Datatype Operator">—↠</a> <a id="1341" href="plfa.Untyped.html#4340" class="InductiveConstructor Operator">ƛ</a> <a id="1343" href="plfa.ContextualEquivalence.html#1317" class="Bound">N</a><a id="1344" class="Symbol">)</a>
</pre>{% endraw %}
So two terms are contextually equivalent if plugging them into the
same context produces two programs that either terminate or diverge
together.

{% raw %}<pre class="Agda"><a id="_≅_"></a><a id="1501" href="{% endraw %}{{ site.baseurl }}{% link out/plfa/ContextualEquivalence.md %}{% raw %}#1501" class="Function Operator">_≅_</a> <a id="1505" class="Symbol">:</a> <a id="1507" class="Symbol">∀{</a><a id="1509" href="plfa.ContextualEquivalence.html#1509" class="Bound">Γ</a><a id="1510" class="Symbol">}</a> <a id="1512" class="Symbol">→</a> <a id="1514" class="Symbol">(</a><a id="1515" href="plfa.ContextualEquivalence.html#1515" class="Bound">M</a> <a id="1517" href="plfa.ContextualEquivalence.html#1517" class="Bound">N</a> <a id="1519" class="Symbol">:</a> <a id="1521" href="plfa.ContextualEquivalence.html#1509" class="Bound">Γ</a> <a id="1523" href="{% endraw %}{{ site.baseurl }}{% link out/plfa/Untyped.md %}{% raw %}#4252" class="Datatype Operator">⊢</a> <a id="1525" href="plfa.Untyped.html#2876" class="InductiveConstructor">★</a><a id="1526" class="Symbol">)</a> <a id="1528" class="Symbol">→</a> <a id="1530" class="PrimitiveType">Set</a>
<a id="1534" class="Symbol">(</a><a id="1535" href="{% endraw %}{{ site.baseurl }}{% link out/plfa/ContextualEquivalence.md %}{% raw %}#1501" class="Function Operator">_≅_</a> <a id="1539" class="Symbol">{</a><a id="1540" href="plfa.ContextualEquivalence.html#1540" class="Bound">Γ</a><a id="1541" class="Symbol">}</a> <a id="1543" href="plfa.ContextualEquivalence.html#1543" class="Bound">M</a> <a id="1545" href="plfa.ContextualEquivalence.html#1545" class="Bound">N</a><a id="1546" class="Symbol">)</a> <a id="1548" class="Symbol">=</a> <a id="1550" class="Symbol">∀</a> <a id="1552" class="Symbol">{</a><a id="1553" href="plfa.ContextualEquivalence.html#1553" class="Bound">C</a> <a id="1555" class="Symbol">:</a> <a id="1557" href="{% endraw %}{{ site.baseurl }}{% link out/plfa/Compositional.md %}{% raw %}#13621" class="Datatype">Ctx</a> <a id="1561" href="plfa.ContextualEquivalence.html#1540" class="Bound">Γ</a> <a id="1563" href="{% endraw %}{{ site.baseurl }}{% link out/plfa/Untyped.md %}{% raw %}#3152" class="InductiveConstructor">∅</a><a id="1564" class="Symbol">}</a>
                <a id="1582" class="Symbol">→</a> <a id="1584" class="Symbol">(</a><a id="1585" href="{% endraw %}{{ site.baseurl }}{% link out/plfa/ContextualEquivalence.md %}{% raw %}#1257" class="Function">terminates</a> <a id="1596" class="Symbol">(</a><a id="1597" href="{% endraw %}{{ site.baseurl }}{% link out/plfa/Compositional.md %}{% raw %}#14673" class="Function">plug</a> <a id="1602" href="plfa.ContextualEquivalence.html#1553" class="Bound">C</a> <a id="1604" href="plfa.ContextualEquivalence.html#1543" class="Bound">M</a><a id="1605" class="Symbol">))</a> <a id="1608" href="{% endraw %}{{ site.baseurl }}{% link out/plfa/Denotational.md %}{% raw %}#16974" class="Function Operator">iff</a> <a id="1612" class="Symbol">(</a><a id="1613" href="plfa.ContextualEquivalence.html#1257" class="Function">terminates</a> <a id="1624" class="Symbol">(</a><a id="1625" href="plfa.Compositional.html#14673" class="Function">plug</a> <a id="1630" href="plfa.ContextualEquivalence.html#1553" class="Bound">C</a> <a id="1632" href="plfa.ContextualEquivalence.html#1545" class="Bound">N</a><a id="1633" class="Symbol">))</a>
</pre>{% endraw %}
The contextual equivalence of two terms is difficult to prove directly
based on the above definition because of the universal quantification
of the context `C`. One of the main motivations for developing
denotational semantics is to have an alternative way to prove
contextual equivalence that instead only requires reasoning about the
two terms.


## Denotational equivalence implies contextual equivalence

Thankfully, the proof that denotational equality implies contextual
equivalence is an easy corollary of the results that we have already
established. Furthermore, the two directions of the if-and-only-if are
symmetric, so we can prove one lemma and then use it twice in the
theorem.

The lemma states that if `M` and `N` are denotationally equal
and if `M` plugged into `C` terminates, then so does
`N` plugged into `C`.

{% raw %}<pre class="Agda"><a id="denot-equal-terminates"></a><a id="2476" href="{% endraw %}{{ site.baseurl }}{% link out/plfa/ContextualEquivalence.md %}{% raw %}#2476" class="Function">denot-equal-terminates</a> <a id="2499" class="Symbol">:</a> <a id="2501" class="Symbol">∀{</a><a id="2503" href="plfa.ContextualEquivalence.html#2503" class="Bound">Γ</a><a id="2504" class="Symbol">}</a> <a id="2506" class="Symbol">{</a><a id="2507" href="plfa.ContextualEquivalence.html#2507" class="Bound">M</a> <a id="2509" href="plfa.ContextualEquivalence.html#2509" class="Bound">N</a> <a id="2511" class="Symbol">:</a> <a id="2513" href="plfa.ContextualEquivalence.html#2503" class="Bound">Γ</a> <a id="2515" href="{% endraw %}{{ site.baseurl }}{% link out/plfa/Untyped.md %}{% raw %}#4252" class="Datatype Operator">⊢</a> <a id="2517" href="plfa.Untyped.html#2876" class="InductiveConstructor">★</a><a id="2518" class="Symbol">}</a> <a id="2520" class="Symbol">{</a><a id="2521" href="plfa.ContextualEquivalence.html#2521" class="Bound">C</a> <a id="2523" class="Symbol">:</a> <a id="2525" href="{% endraw %}{{ site.baseurl }}{% link out/plfa/Compositional.md %}{% raw %}#13621" class="Datatype">Ctx</a> <a id="2529" href="plfa.ContextualEquivalence.html#2503" class="Bound">Γ</a> <a id="2531" href="plfa.Untyped.html#3152" class="InductiveConstructor">∅</a><a id="2532" class="Symbol">}</a>
  <a id="2536" class="Symbol">→</a> <a id="2538" href="{% endraw %}{{ site.baseurl }}{% link out/plfa/Denotational.md %}{% raw %}#17453" class="Function">ℰ</a> <a id="2540" href="{% endraw %}{{ site.baseurl }}{% link out/plfa/ContextualEquivalence.md %}{% raw %}#2507" class="Bound">M</a> <a id="2542" href="plfa.Denotational.html#17635" class="Function Operator">≃</a> <a id="2544" href="plfa.Denotational.html#17453" class="Function">ℰ</a> <a id="2546" href="plfa.ContextualEquivalence.html#2509" class="Bound">N</a>  <a id="2549" class="Symbol">→</a>  <a id="2552" href="plfa.ContextualEquivalence.html#1257" class="Function">terminates</a> <a id="2563" class="Symbol">(</a><a id="2564" href="{% endraw %}{{ site.baseurl }}{% link out/plfa/Compositional.md %}{% raw %}#14673" class="Function">plug</a> <a id="2569" href="plfa.ContextualEquivalence.html#2521" class="Bound">C</a> <a id="2571" href="plfa.ContextualEquivalence.html#2507" class="Bound">M</a><a id="2572" class="Symbol">)</a>
    <a id="2578" class="Comment">-----------------------------------</a>
  <a id="2616" class="Symbol">→</a> <a id="2618" href="{% endraw %}{{ site.baseurl }}{% link out/plfa/ContextualEquivalence.md %}{% raw %}#1257" class="Function">terminates</a> <a id="2629" class="Symbol">(</a><a id="2630" href="{% endraw %}{{ site.baseurl }}{% link out/plfa/Compositional.md %}{% raw %}#14673" class="Function">plug</a> <a id="2635" href="plfa.ContextualEquivalence.html#2521" class="Bound">C</a> <a id="2637" href="plfa.ContextualEquivalence.html#2509" class="Bound">N</a><a id="2638" class="Symbol">)</a>
<a id="2640" href="{% endraw %}{{ site.baseurl }}{% link out/plfa/ContextualEquivalence.md %}{% raw %}#2476" class="Function">denot-equal-terminates</a> <a id="2663" class="Symbol">{</a><a id="2664" href="plfa.ContextualEquivalence.html#2664" class="Bound">Γ</a><a id="2665" class="Symbol">}{</a><a id="2667" href="plfa.ContextualEquivalence.html#2667" class="Bound">M</a><a id="2668" class="Symbol">}{</a><a id="2670" href="plfa.ContextualEquivalence.html#2670" class="Bound">N</a><a id="2671" class="Symbol">}{</a><a id="2673" href="plfa.ContextualEquivalence.html#2673" class="Bound">C</a><a id="2674" class="Symbol">}</a> <a id="2676" href="plfa.ContextualEquivalence.html#2676" class="Bound">ℰM≃ℰN</a> <a id="2682" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">⟨</a> <a id="2684" href="plfa.ContextualEquivalence.html#2684" class="Bound">N′</a> <a id="2687" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="2689" href="plfa.ContextualEquivalence.html#2689" class="Bound">CM—↠ƛN′</a> <a id="2697" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">⟩</a> <a id="2699" class="Symbol">=</a>
  <a id="2703" class="Keyword">let</a> <a id="2707" href="{% endraw %}{{ site.baseurl }}{% link out/plfa/ContextualEquivalence.md %}{% raw %}#2707" class="Bound">ℰCM≃ℰƛN′</a> <a id="2716" class="Symbol">=</a> <a id="2718" href="{% endraw %}{{ site.baseurl }}{% link out/plfa/Soundness.md %}{% raw %}#23397" class="Function">soundness</a> <a id="2728" href="plfa.ContextualEquivalence.html#2689" class="Bound">CM—↠ƛN′</a> <a id="2736" class="Keyword">in</a>
  <a id="2741" class="Keyword">let</a> <a id="2745" href="{% endraw %}{{ site.baseurl }}{% link out/plfa/ContextualEquivalence.md %}{% raw %}#2745" class="Bound">ℰCM≃ℰCN</a> <a id="2753" class="Symbol">=</a> <a id="2755" href="{% endraw %}{{ site.baseurl }}{% link out/plfa/Compositional.md %}{% raw %}#15068" class="Function">compositionality</a><a id="2771" class="Symbol">{</a><a id="2772" class="Argument">Γ</a> <a id="2774" class="Symbol">=</a> <a id="2776" href="plfa.ContextualEquivalence.html#2664" class="Bound">Γ</a><a id="2777" class="Symbol">}{</a><a id="2779" class="Argument">Δ</a> <a id="2781" class="Symbol">=</a> <a id="2783" href="{% endraw %}{{ site.baseurl }}{% link out/plfa/Untyped.md %}{% raw %}#3152" class="InductiveConstructor">∅</a><a id="2784" class="Symbol">}{</a><a id="2786" class="Argument">C</a> <a id="2788" class="Symbol">=</a> <a id="2790" href="plfa.ContextualEquivalence.html#2673" class="Bound">C</a><a id="2791" class="Symbol">}</a> <a id="2793" href="plfa.ContextualEquivalence.html#2676" class="Bound">ℰM≃ℰN</a> <a id="2799" class="Keyword">in</a>
  <a id="2804" class="Keyword">let</a> <a id="2808" href="{% endraw %}{{ site.baseurl }}{% link out/plfa/ContextualEquivalence.md %}{% raw %}#2808" class="Bound">ℰCN≃ℰƛN′</a> <a id="2817" class="Symbol">=</a> <a id="2819" href="{% endraw %}{{ site.baseurl }}{% link out/plfa/Denotational.md %}{% raw %}#18040" class="Function">≃-trans</a> <a id="2827" class="Symbol">(</a><a id="2828" href="plfa.Denotational.html#17907" class="Function">≃-sym</a> <a id="2834" href="plfa.ContextualEquivalence.html#2745" class="Bound">ℰCM≃ℰCN</a><a id="2841" class="Symbol">)</a> <a id="2843" href="plfa.ContextualEquivalence.html#2707" class="Bound">ℰCM≃ℰƛN′</a> <a id="2852" class="Keyword">in</a>
    <a id="2859" href="{% endraw %}{{ site.baseurl }}{% link out/plfa/CallByName.md %}{% raw %}#12248" class="Function">cbn→reduce</a> <a id="2870" class="Symbol">(</a><a id="2871" href="Agda.Builtin.Sigma.html#237" class="Field">proj₂</a> <a id="2877" class="Symbol">(</a><a id="2878" href="Agda.Builtin.Sigma.html#237" class="Field">proj₂</a> <a id="2884" class="Symbol">(</a><a id="2885" href="Agda.Builtin.Sigma.html#237" class="Field">proj₂</a> <a id="2891" class="Symbol">(</a><a id="2892" href="{% endraw %}{{ site.baseurl }}{% link out/plfa/Adequacy.md %}{% raw %}#20838" class="Function">adequacy</a> <a id="2901" href="{% endraw %}{{ site.baseurl }}{% link out/plfa/ContextualEquivalence.md %}{% raw %}#2808" class="Bound">ℰCN≃ℰƛN′</a><a id="2909" class="Symbol">))))</a>
</pre>{% endraw %}
The proof is direct. Because `plug C —↠ plug C (ƛN′)`,
we can apply soundness to obtain

    ℰ (plug C M) ≃ ℰ (ƛN′)

From `ℰ M ≃ ℰ N`, compositionality gives us

    ℰ (plug C M) ≃ ℰ (plug C N).

Putting these two facts together gives us

    ℰ (plug C N) ≃ ℰ (ƛN′).

We then apply adequacy to deduce

    ∅' ⊢ plug C N ⇓ clos (ƛ N′′) δ).

Call-by-name evaluation implies reduction to a lambda abstraction,
so we conclude that

    terminates (plug C N).


The main theorem follows by two applications of the lemma.

{% raw %}<pre class="Agda"><a id="denot-equal-contex-equal"></a><a id="3440" href="{% endraw %}{{ site.baseurl }}{% link out/plfa/ContextualEquivalence.md %}{% raw %}#3440" class="Function">denot-equal-contex-equal</a> <a id="3465" class="Symbol">:</a> <a id="3467" class="Symbol">∀{</a><a id="3469" href="plfa.ContextualEquivalence.html#3469" class="Bound">Γ</a><a id="3470" class="Symbol">}</a> <a id="3472" class="Symbol">{</a><a id="3473" href="plfa.ContextualEquivalence.html#3473" class="Bound">M</a> <a id="3475" href="plfa.ContextualEquivalence.html#3475" class="Bound">N</a> <a id="3477" class="Symbol">:</a> <a id="3479" href="plfa.ContextualEquivalence.html#3469" class="Bound">Γ</a> <a id="3481" href="{% endraw %}{{ site.baseurl }}{% link out/plfa/Untyped.md %}{% raw %}#4252" class="Datatype Operator">⊢</a> <a id="3483" href="plfa.Untyped.html#2876" class="InductiveConstructor">★</a><a id="3484" class="Symbol">}</a>
  <a id="3488" class="Symbol">→</a> <a id="3490" href="{% endraw %}{{ site.baseurl }}{% link out/plfa/Denotational.md %}{% raw %}#17453" class="Function">ℰ</a> <a id="3492" href="{% endraw %}{{ site.baseurl }}{% link out/plfa/ContextualEquivalence.md %}{% raw %}#3473" class="Bound">M</a> <a id="3494" href="plfa.Denotational.html#17635" class="Function Operator">≃</a> <a id="3496" href="plfa.Denotational.html#17453" class="Function">ℰ</a> <a id="3498" href="plfa.ContextualEquivalence.html#3475" class="Bound">N</a>
    <a id="3504" class="Comment">---------</a>
  <a id="3516" class="Symbol">→</a> <a id="3518" href="{% endraw %}{{ site.baseurl }}{% link out/plfa/ContextualEquivalence.md %}{% raw %}#3473" class="Bound">M</a> <a id="3520" href="plfa.ContextualEquivalence.html#1501" class="Function Operator">≅</a> <a id="3522" href="plfa.ContextualEquivalence.html#3475" class="Bound">N</a>
<a id="3524" href="{% endraw %}{{ site.baseurl }}{% link out/plfa/ContextualEquivalence.md %}{% raw %}#3440" class="Function">denot-equal-contex-equal</a><a id="3548" class="Symbol">{</a><a id="3549" href="plfa.ContextualEquivalence.html#3549" class="Bound">Γ</a><a id="3550" class="Symbol">}{</a><a id="3552" href="plfa.ContextualEquivalence.html#3552" class="Bound">M</a><a id="3553" class="Symbol">}{</a><a id="3555" href="plfa.ContextualEquivalence.html#3555" class="Bound">N</a><a id="3556" class="Symbol">}</a> <a id="3558" href="plfa.ContextualEquivalence.html#3558" class="Bound">eq</a> <a id="3561" class="Symbol">{</a><a id="3562" href="plfa.ContextualEquivalence.html#3562" class="Bound">C</a><a id="3563" class="Symbol">}</a> <a id="3565" class="Symbol">=</a>
   <a id="3570" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">⟨</a> <a id="3572" class="Symbol">(λ</a> <a id="3575" href="{% endraw %}{{ site.baseurl }}{% link out/plfa/ContextualEquivalence.md %}{% raw %}#3575" class="Bound">tm</a> <a id="3578" class="Symbol">→</a> <a id="3580" href="plfa.ContextualEquivalence.html#2476" class="Function">denot-equal-terminates</a> <a id="3603" href="plfa.ContextualEquivalence.html#3558" class="Bound">eq</a> <a id="3606" href="plfa.ContextualEquivalence.html#3575" class="Bound">tm</a><a id="3608" class="Symbol">)</a> <a id="3610" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a>
     <a id="3617" class="Symbol">(λ</a> <a id="3620" href="{% endraw %}{{ site.baseurl }}{% link out/plfa/ContextualEquivalence.md %}{% raw %}#3620" class="Bound">tn</a> <a id="3623" class="Symbol">→</a> <a id="3625" href="plfa.ContextualEquivalence.html#2476" class="Function">denot-equal-terminates</a> <a id="3648" class="Symbol">(</a><a id="3649" href="{% endraw %}{{ site.baseurl }}{% link out/plfa/Denotational.md %}{% raw %}#17907" class="Function">≃-sym</a> <a id="3655" href="plfa.ContextualEquivalence.html#3558" class="Bound">eq</a><a id="3657" class="Symbol">)</a> <a id="3659" href="plfa.ContextualEquivalence.html#3620" class="Bound">tn</a><a id="3661" class="Symbol">)</a> <a id="3663" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">⟩</a>
</pre>{% endraw %}

## Unicode

This chapter uses the following unicode:

    ≅  U+2245  APPROXIMATELY EQUAL TO (\~= or \cong)
